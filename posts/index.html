<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>Posts :: Matteo Site</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="http://localhost:1313/posts/" />





  
  <link rel="stylesheet" href="http://localhost:1313/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="website" />
<meta property="og:title" content="Posts">
<meta property="og:description" content="" />
<meta property="og:url" content="http://localhost:1313/posts/" />
<meta property="og:site_name" content="Matteo Site" />

  <meta property="og:image" content="http://localhost:1313/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">





  <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Matteo Site" />









</head>
<body>


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="http://localhost:1313/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
    
  </div>
  
</header>


  <div class="content">
    
  
  <div class="posts">
    
      <article class="post on-list">
        <h2 class="post-title">
          <a href="http://localhost:1313/posts/prova_codice/">Prova_codice</a>
        </h2>
        <div class="post-meta"><time class="post-date">2025-06-13</time></div>

        
          <span class="post-tags">
            
            #<a href="http://localhost:1313/tags/"></a>&nbsp;
            
            #<a href="http://localhost:1313/tags/"></a>&nbsp;
            
          </span>
        

        


        <div class="post-content">
          
            <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma once
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdexcept&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Key, <span style="color:#66d9ef">typename</span> Val, <span style="color:#66d9ef">int</span> M<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BTree</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// M is the minimum degree of the B-tree.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Max keys in a node: 2*M - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Min keys in a non-root node: M - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> is_leaf;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span> keys;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Val<span style="color:#f92672">&gt;</span> vals;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Node <span style="color:#f92672">*&gt;</span> children;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node(<span style="color:#66d9ef">bool</span> leaf <span style="color:#f92672">=</span> false) <span style="color:#f92672">:</span> is_leaf(leaf) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// NOTE: destructor called recursively
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>Node() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> (Node <span style="color:#f92672">*</span>child : children) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> child;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Node <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> _size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> _height <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> split_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_clear</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">delete</span> node; <span style="color:#75715e">// The destructor of sruct Node deletes children recursively
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: Functions for search in this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  Val <span style="color:#f92672">*</span><span style="color:#a6e22e">_search</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// STL binary search to get first element &gt;= to k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(node<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys.end(), k);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get index from iterator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(node<span style="color:#f92672">-&gt;</span>keys.begin(), it);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// found k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.end() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>node<span style="color:#f92672">-&gt;</span>vals[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> _search(node<span style="color:#f92672">-&gt;</span>children[i], k);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: Functions for insertion in this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// splits the child at `parent-&gt;children[child_index]`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_split_child</span>(Node <span style="color:#f92672">*</span>parent, <span style="color:#66d9ef">int</span> child_index) {
</span></span><span style="display:flex;"><span>    split_counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child_to_split <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>children[child_index];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// create new sibling for splitting the node in half
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>new_child <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(child_to_split<span style="color:#f92672">-&gt;</span>is_leaf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Promote the median key and value to the parent node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">-&gt;</span>keys.insert(parent<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> child_index,
</span></span><span style="display:flex;"><span>                        child_to_split<span style="color:#f92672">-&gt;</span>keys[M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    parent<span style="color:#f92672">-&gt;</span>vals.insert(parent<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> child_index,
</span></span><span style="display:flex;"><span>                        child_to_split<span style="color:#f92672">-&gt;</span>vals[M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Put the sibling as a child of the parent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// It will be the sibling  to the right of the split node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">-&gt;</span>children.insert(parent<span style="color:#f92672">-&gt;</span>children.begin() <span style="color:#f92672">+</span> child_index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                            new_child);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// move half of keys and values to the split node&#39;s sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    new_child<span style="color:#f92672">-&gt;</span>keys.assign(child_to_split<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> M,
</span></span><span style="display:flex;"><span>                           child_to_split<span style="color:#f92672">-&gt;</span>keys.end());
</span></span><span style="display:flex;"><span>    new_child<span style="color:#f92672">-&gt;</span>vals.assign(child_to_split<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> M,
</span></span><span style="display:flex;"><span>                           child_to_split<span style="color:#f92672">-&gt;</span>vals.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child_to_split<span style="color:#f92672">-&gt;</span>keys.resize(M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    child_to_split<span style="color:#f92672">-&gt;</span>vals.resize(M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if the split node was not a leaf, move its children into its new sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child_to_split<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      new_child<span style="color:#f92672">-&gt;</span>children.assign(child_to_split<span style="color:#f92672">-&gt;</span>children.begin() <span style="color:#f92672">+</span> M,
</span></span><span style="display:flex;"><span>                                 child_to_split<span style="color:#f92672">-&gt;</span>children.end());
</span></span><span style="display:flex;"><span>      child_to_split<span style="color:#f92672">-&gt;</span>children.resize(M);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: IMPORTANT INVARIANT node should not be already full
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// otherwise it will overflow, only call this from public method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_insert_rec</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">const</span> Val <span style="color:#f92672">&amp;</span>v) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// STL binary search to get index of first key &gt;= k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(node<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys.end(), k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(node<span style="color:#f92672">-&gt;</span>keys.begin(),
</span></span><span style="display:flex;"><span>                          it); <span style="color:#75715e">// get index in vector of iterator it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// case where we found already existing key, update the val
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.end() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// regular case just insert the key in the leaf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      node<span style="color:#f92672">-&gt;</span>keys.insert(it, k);
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>vals.insert(node<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> i, v);
</span></span><span style="display:flex;"><span>      _size<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// case where we found already existing key, update the val, same as in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// leaf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.end() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// NOTE: important, guarantees that no node will overflow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// splits the child we will visit recursively in case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// it&#39;s already full
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        _split_child(node, i);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// increase variabile i in case i need to go to the new sibling after
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// the split
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>keys[i]) {
</span></span><span style="display:flex;"><span>          i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      _insert_rec(node<span style="color:#f92672">-&gt;</span>children[i], k, v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: Functions for deletion in this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;</span> _get_pred(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>cur<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>children.back();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {cur<span style="color:#f92672">-&gt;</span>keys.back(), cur<span style="color:#f92672">-&gt;</span>vals.back()};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;</span> _get_succ(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>cur<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>children.front();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {cur<span style="color:#f92672">-&gt;</span>keys.front(), cur<span style="color:#f92672">-&gt;</span>vals.front()};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_borrow_from_prev</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>sibling <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// take key from parent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    child<span style="color:#f92672">-&gt;</span>keys.insert(child<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.insert(child<span style="color:#f92672">-&gt;</span>vals.begin(), node<span style="color:#f92672">-&gt;</span>vals[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// eventually add children inherited from key taken from parent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      child<span style="color:#f92672">-&gt;</span>children.insert(child<span style="color:#f92672">-&gt;</span>children.begin(), sibling<span style="color:#f92672">-&gt;</span>children.back());
</span></span><span style="display:flex;"><span>      sibling<span style="color:#f92672">-&gt;</span>children.pop_back();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>keys.back();
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>vals.back();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>keys.pop_back();
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>vals.pop_back();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_borrow_from_next</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>sibling <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>keys.push_back(node<span style="color:#f92672">-&gt;</span>keys[i]);
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.push_back(node<span style="color:#f92672">-&gt;</span>vals[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      child<span style="color:#f92672">-&gt;</span>children.push_back(sibling<span style="color:#f92672">-&gt;</span>children.front());
</span></span><span style="display:flex;"><span>      sibling<span style="color:#f92672">-&gt;</span>children.erase(sibling<span style="color:#f92672">-&gt;</span>children.begin());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>keys.front();
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>vals.front();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>keys.erase(sibling<span style="color:#f92672">-&gt;</span>keys.begin());
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>vals.erase(sibling<span style="color:#f92672">-&gt;</span>vals.begin());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_merge</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>sibling <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>keys.push_back(node<span style="color:#f92672">-&gt;</span>keys[i]);
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.push_back(node<span style="color:#f92672">-&gt;</span>vals[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>keys.insert(child<span style="color:#f92672">-&gt;</span>keys.end(), sibling<span style="color:#f92672">-&gt;</span>keys.begin(),
</span></span><span style="display:flex;"><span>                       sibling<span style="color:#f92672">-&gt;</span>keys.end());
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.insert(child<span style="color:#f92672">-&gt;</span>vals.end(), sibling<span style="color:#f92672">-&gt;</span>vals.begin(),
</span></span><span style="display:flex;"><span>                       sibling<span style="color:#f92672">-&gt;</span>vals.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      child<span style="color:#f92672">-&gt;</span>children.insert(child<span style="color:#f92672">-&gt;</span>children.end(), sibling<span style="color:#f92672">-&gt;</span>children.begin(),
</span></span><span style="display:flex;"><span>                             sibling<span style="color:#f92672">-&gt;</span>children.end());
</span></span><span style="display:flex;"><span>      sibling<span style="color:#f92672">-&gt;</span>children.clear(); <span style="color:#75715e">// Important: prevent double deletion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys.erase(node<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals.erase(node<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>children.erase(node<span style="color:#f92672">-&gt;</span>children.begin() <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> sibling;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_fill</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if i can borrow from left sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      _borrow_from_prev(node, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if i can borrow from right sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>               node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      _borrow_from_next(node, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if i cannot borrow i need to merge the siblings into a node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.size()) {
</span></span><span style="display:flex;"><span>        _merge(node, i);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        _merge(node, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_remove_in_leaf</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys.erase(node<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals.erase(node<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    _size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_remove_in_internal</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Key k <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>keys[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">auto</span> [pred_key, pred_val] <span style="color:#f92672">=</span> _get_pred(node, i);
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">=</span> pred_key;
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> pred_val;
</span></span><span style="display:flex;"><span>      _remove(node<span style="color:#f92672">-&gt;</span>children[i], pred_key);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">auto</span> [succ_key, succ_val] <span style="color:#f92672">=</span> _get_succ(node, i);
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">=</span> succ_key;
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> succ_val;
</span></span><span style="display:flex;"><span>      _remove(node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], succ_key);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      _merge(node, i);
</span></span><span style="display:flex;"><span>      _remove(node<span style="color:#f92672">-&gt;</span>children[i], k);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_remove</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// STL binary search to get index of first key &gt;= k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(node<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys.end(), k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(node<span style="color:#f92672">-&gt;</span>keys.begin(), it);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>        _remove_in_leaf(node, i);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        _remove_in_internal(node, i);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// key not found nothing is removed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">bool</span> is_last_child <span style="color:#f92672">=</span> (i <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>keys.size());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// to keep invariant about minimum number of keys
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// in a node is &gt;= M-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&lt;</span> M) {
</span></span><span style="display:flex;"><span>        _fill(node, i);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (is_last_child <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>keys.size()) {
</span></span><span style="display:flex;"><span>        _remove(node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], k);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        _remove(node<span style="color:#f92672">-&gt;</span>children[i], k);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: other functions not related to search, insertio and removal in this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_inorder</span>(Node <span style="color:#f92672">*</span>node, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span>v) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>keys.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>        _inorder(node<span style="color:#f92672">-&gt;</span>children[i], v);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      v.push_back(std<span style="color:#f92672">::</span>make_pair(node<span style="color:#f92672">-&gt;</span>keys[i], node<span style="color:#f92672">-&gt;</span>vals[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      _inorder(node<span style="color:#f92672">-&gt;</span>children[i], v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: only used for testing the actual height
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// computation dont use this, it&#39;s super naive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_height_naive</span>(Node <span style="color:#f92672">*</span>node) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> max_child_height <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (Node <span style="color:#f92672">*</span>child : node<span style="color:#f92672">-&gt;</span>children) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> child_height <span style="color:#f92672">=</span> _height_naive(child);
</span></span><span style="display:flex;"><span>      max_child_height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(max_child_height, child_height);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max_child_height;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  BTree() { root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(true); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">~</span>BTree() { _clear(root); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _size; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">const</span> Val <span style="color:#f92672">&amp;</span>v) {
</span></span><span style="display:flex;"><span>    split_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if root is full make a new one with old root as child
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (r<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>      Node <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node();
</span></span><span style="display:flex;"><span>      root <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>      s<span style="color:#f92672">-&gt;</span>children.push_back(r);
</span></span><span style="display:flex;"><span>      _split_child(s, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">++</span>_height;
</span></span><span style="display:flex;"><span>      _insert_rec(s, k, v);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      _insert_rec(r, k, v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _remove(root, k);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// NOTE: case where we need to shrink tree height by 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>keys.empty() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>root<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      Node <span style="color:#f92672">*</span>old_root <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>      root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>children[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>      old_root<span style="color:#f92672">-&gt;</span>children
</span></span><span style="display:flex;"><span>          .clear(); <span style="color:#75715e">// Prevent destructor from deleting the new root
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">delete</span> old_root;
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">--</span>_height;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Val <span style="color:#f92672">&amp;</span>search(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    Val <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> _search(root, k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(<span style="color:#e6db74">&#34;Key not found&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Val <span style="color:#f92672">&amp;</span>search(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    Val <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> _search(root, k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(<span style="color:#e6db74">&#34;Key not found&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contains</span>(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) { <span style="color:#66d9ef">return</span> _search(root, k) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inorder_vector</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span>v) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    v.clear();
</span></span><span style="display:flex;"><span>    _inorder(root, v);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">height</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _height; }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">last_insert_splits</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> split_counter; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clear</span>() {
</span></span><span style="display:flex;"><span>    _clear(root);
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(true);
</span></span><span style="display:flex;"><span>    _size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: only used for testing the actual height
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// computation dont use this, it&#39;s super naive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_height_naive</span>() { <span style="color:#66d9ef">return</span> _height_naive(root); }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>
          
        </div>

        
           <div>
            <a class="read-more button inline" href="/posts/prova_codice/">[]</a>
          </div>
        
      </article>
    
      <article class="post on-list">
        <h2 class="post-title">
          <a href="http://localhost:1313/posts/prova/">prova</a>
        </h2>
        <div class="post-meta"><time class="post-date">2025-06-12</time></div>

        

        


        <div class="post-content">
          
            <p>Pagina di prova! Vediamo se funziona 😳</p>
          
        </div>

        
           <div>
            <a class="read-more button inline" href="/posts/prova/">[]</a>
          </div>
        
      </article>
    

    <div class="pagination">
  <div class="pagination__buttons">
    
    
    
  </div>
</div>

  </div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
