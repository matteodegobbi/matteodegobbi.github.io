<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Prova_codice :: Matteo Site</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content=" #pragma once #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;stdexcept&gt; #include &lt;utility&gt; #include &lt;vector&gt; template &lt;typename Key, typename Val, int M&gt; class BTree { // M is the minimum degree of the B-tree. // Max keys in a node: 2*M - 1 // Min keys in a non-root node: M - 1 private: struct Node { bool is_leaf; std::vector&lt;Key&gt; keys; std::vector&lt;Val&gt; vals; std::vector&lt;Node *&gt; children; Node(bool leaf = false) : is_leaf(leaf) {} // NOTE: destructor called recursively ~Node() { for (Node *child : children) { delete child; } } }; Node *root = nullptr; int _size = 0; int _height = 0; int split_counter = 0; void _clear(Node *node) { if (node != nullptr) { delete node; // The destructor of sruct Node deletes children recursively } } // NOTE: Functions for search in this section Val *_search(Node *node, const Key &amp;k) { if (node == nullptr) { return nullptr; } // STL binary search to get first element &gt;= to k auto it = std::lower_bound(node-&gt;keys.begin(), node-&gt;keys.end(), k); // get index from iterator int i = std::distance(node-&gt;keys.begin(), it); // found k if (it != node-&gt;keys.end() &amp;&amp; *it == k) { return &amp;node-&gt;vals[i]; } if (node-&gt;is_leaf) { return nullptr; } return _search(node-&gt;children[i], k); } // NOTE: Functions for insertion in this section // // splits the child at `parent-&gt;children[child_index]` void _split_child(Node *parent, int child_index) { split_counter&#43;&#43;; Node *child_to_split = parent-&gt;children[child_index]; // create new sibling for splitting the node in half Node *new_child = new Node(child_to_split-&gt;is_leaf); // Promote the median key and value to the parent node parent-&gt;keys.insert(parent-&gt;keys.begin() &#43; child_index, child_to_split-&gt;keys[M - 1]); parent-&gt;vals.insert(parent-&gt;vals.begin() &#43; child_index, child_to_split-&gt;vals[M - 1]); // Put the sibling as a child of the parent // It will be the sibling to the right of the split node parent-&gt;children.insert(parent-&gt;children.begin() &#43; child_index &#43; 1, new_child); // move half of keys and values to the split node&#39;s sibling new_child-&gt;keys.assign(child_to_split-&gt;keys.begin() &#43; M, child_to_split-&gt;keys.end()); new_child-&gt;vals.assign(child_to_split-&gt;vals.begin() &#43; M, child_to_split-&gt;vals.end()); child_to_split-&gt;keys.resize(M - 1); child_to_split-&gt;vals.resize(M - 1); // if the split node was not a leaf, move its children into its new sibling if (!child_to_split-&gt;is_leaf) { new_child-&gt;children.assign(child_to_split-&gt;children.begin() &#43; M, child_to_split-&gt;children.end()); child_to_split-&gt;children.resize(M); } } // NOTE: IMPORTANT INVARIANT node should not be already full // otherwise it will overflow, only call this from public method void _insert_rec(Node *node, const Key &amp;k, const Val &amp;v) { // STL binary search to get index of first key &gt;= k auto it = std::lower_bound(node-&gt;keys.begin(), node-&gt;keys.end(), k); int i = std::distance(node-&gt;keys.begin(), it); // get index in vector of iterator it if (node-&gt;is_leaf) { // case where we found already existing key, update the val if (it != node-&gt;keys.end() &amp;&amp; *it == k) { node-&gt;vals[i] = v; return; } // regular case just insert the key in the leaf node-&gt;keys.insert(it, k); node-&gt;vals.insert(node-&gt;vals.begin() &#43; i, v); _size&#43;&#43;; } else { // case where we found already existing key, update the val, same as in // leaf if (it != node-&gt;keys.end() &amp;&amp; *it == k) { node-&gt;vals[i] = v; return; } // NOTE: important, guarantees that no node will overflow // splits the child we will visit recursively in case // it&#39;s already full if (node-&gt;children[i]-&gt;keys.size() == 2 * M - 1) { _split_child(node, i); // increase variabile i in case i need to go to the new sibling after // the split if (k &gt; node-&gt;keys[i]) { i&#43;&#43;; } } _insert_rec(node-&gt;children[i], k, v); } } // NOTE: Functions for deletion in this section std::pair&lt;Key, Val&gt; _get_pred(Node *node, int i) { Node *cur = node-&gt;children[i]; while (!cur-&gt;is_leaf) { cur = cur-&gt;children.back(); } return {cur-&gt;keys.back(), cur-&gt;vals.back()}; } std::pair&lt;Key, Val&gt; _get_succ(Node *node, int i) { Node *cur = node-&gt;children[i &#43; 1]; while (!cur-&gt;is_leaf) { cur = cur-&gt;children.front(); } return {cur-&gt;keys.front(), cur-&gt;vals.front()}; } void _borrow_from_prev(Node *node, int i) { Node *child = node-&gt;children[i]; Node *sibling = node-&gt;children[i - 1]; // take key from parent child-&gt;keys.insert(child-&gt;keys.begin(), node-&gt;keys[i - 1]); child-&gt;vals.insert(child-&gt;vals.begin(), node-&gt;vals[i - 1]); // eventually add children inherited from key taken from parent if (!child-&gt;is_leaf) { child-&gt;children.insert(child-&gt;children.begin(), sibling-&gt;children.back()); sibling-&gt;children.pop_back(); } node-&gt;keys[i - 1] = sibling-&gt;keys.back(); node-&gt;vals[i - 1] = sibling-&gt;vals.back(); sibling-&gt;keys.pop_back(); sibling-&gt;vals.pop_back(); } void _borrow_from_next(Node *node, int i) { Node *child = node-&gt;children[i]; Node *sibling = node-&gt;children[i &#43; 1]; child-&gt;keys.push_back(node-&gt;keys[i]); child-&gt;vals.push_back(node-&gt;vals[i]); if (!child-&gt;is_leaf) { child-&gt;children.push_back(sibling-&gt;children.front()); sibling-&gt;children.erase(sibling-&gt;children.begin()); } node-&gt;keys[i] = sibling-&gt;keys.front(); node-&gt;vals[i] = sibling-&gt;vals.front(); sibling-&gt;keys.erase(sibling-&gt;keys.begin()); sibling-&gt;vals.erase(sibling-&gt;vals.begin()); } void _merge(Node *node, int i) { Node *child = node-&gt;children[i]; Node *sibling = node-&gt;children[i &#43; 1]; child-&gt;keys.push_back(node-&gt;keys[i]); child-&gt;vals.push_back(node-&gt;vals[i]); child-&gt;keys.insert(child-&gt;keys.end(), sibling-&gt;keys.begin(), sibling-&gt;keys.end()); child-&gt;vals.insert(child-&gt;vals.end(), sibling-&gt;vals.begin(), sibling-&gt;vals.end()); if (!child-&gt;is_leaf) { child-&gt;children.insert(child-&gt;children.end(), sibling-&gt;children.begin(), sibling-&gt;children.end()); sibling-&gt;children.clear(); // Important: prevent double deletion } node-&gt;keys.erase(node-&gt;keys.begin() &#43; i); node-&gt;vals.erase(node-&gt;vals.begin() &#43; i); node-&gt;children.erase(node-&gt;children.begin() &#43; i &#43; 1); delete sibling; } void _fill(Node *node, int i) { // if i can borrow from left sibling if (i != 0 &amp;&amp; node-&gt;children[i - 1]-&gt;keys.size() &gt;= M) { _borrow_from_prev(node, i); // if i can borrow from right sibling } else if (i != node-&gt;keys.size() &amp;&amp; node-&gt;children[i &#43; 1]-&gt;keys.size() &gt;= M) { _borrow_from_next(node, i); // if i cannot borrow i need to merge the siblings into a node } else { if (i != node-&gt;keys.size()) { _merge(node, i); } else { _merge(node, i - 1); } } } void _remove_in_leaf(Node *node, int i) { node-&gt;keys.erase(node-&gt;keys.begin() &#43; i); node-&gt;vals.erase(node-&gt;vals.begin() &#43; i); _size--; } void _remove_in_internal(Node *node, int i) { Key k = node-&gt;keys[i]; if (node-&gt;children[i]-&gt;keys.size() &gt;= M) { auto [pred_key, pred_val] = _get_pred(node, i); node-&gt;keys[i] = pred_key; node-&gt;vals[i] = pred_val; _remove(node-&gt;children[i], pred_key); } else if (node-&gt;children[i &#43; 1]-&gt;keys.size() &gt;= M) { auto [succ_key, succ_val] = _get_succ(node, i); node-&gt;keys[i] = succ_key; node-&gt;vals[i] = succ_val; _remove(node-&gt;children[i &#43; 1], succ_key); } else { _merge(node, i); _remove(node-&gt;children[i], k); } } void _remove(Node *node, const Key &amp;k) { // STL binary search to get index of first key &gt;= k auto it = std::lower_bound(node-&gt;keys.begin(), node-&gt;keys.end(), k); int i = std::distance(node-&gt;keys.begin(), it); if (i &lt; node-&gt;keys.size() &amp;&amp; node-&gt;keys[i] == k) { if (node-&gt;is_leaf) { _remove_in_leaf(node, i); } else { _remove_in_internal(node, i); } } else { if (node-&gt;is_leaf) { return; // key not found nothing is removed } bool is_last_child = (i == node-&gt;keys.size()); // to keep invariant about minimum number of keys // in a node is &gt;= M-1 if (node-&gt;children[i]-&gt;keys.size() &lt; M) { _fill(node, i); } if (is_last_child &amp;&amp; i &gt; node-&gt;keys.size()) { _remove(node-&gt;children[i - 1], k); } else { _remove(node-&gt;children[i], k); } } } // NOTE: other functions not related to search, insertio and removal in this // section void _inorder(Node *node, std::vector&lt;std::pair&lt;Key, Val&gt;&gt; &amp;v) const { if (node == nullptr) return; int i; for (i = 0; i &lt; node-&gt;keys.size(); i&#43;&#43;) { if (!node-&gt;is_leaf) { _inorder(node-&gt;children[i], v); } v.push_back(std::make_pair(node-&gt;keys[i], node-&gt;vals[i])); } if (!node-&gt;is_leaf) { _inorder(node-&gt;children[i], v); } } // NOTE: only used for testing the actual height // computation dont use this, it&#39;s super naive int _height_naive(Node *node) const { if (node == nullptr) { return -1; } if (node-&gt;is_leaf) { return 0; } int max_child_height = -1; for (Node *child : node-&gt;children) { int child_height = _height_naive(child); max_child_height = std::max(max_child_height, child_height); } return 1 &#43; max_child_height; } public: BTree() { root = new Node(true); } ~BTree() { _clear(root); } int size() const { return _size; } bool empty() const { return _size == 0; } void insert(const Key &amp;k, const Val &amp;v) { split_counter = 0; Node *r = root; // if root is full make a new one with old root as child if (r-&gt;keys.size() == 2 * M - 1) { Node *s = new Node(); root = s; s-&gt;children.push_back(r); _split_child(s, 0); &#43;&#43;_height; _insert_rec(s, k, v); } else { _insert_rec(r, k, v); } } void remove(const Key &amp;k) { if (!root) { return; } _remove(root, k); // NOTE: case where we need to shrink tree height by 1 if (root-&gt;keys.empty() &amp;&amp; !root-&gt;is_leaf) { Node *old_root = root; root = root-&gt;children[0]; old_root-&gt;children .clear(); // Prevent destructor from deleting the new root delete old_root; --_height; } } Val &amp;search(const Key &amp;k) { Val *result = _search(root, k); if (result == nullptr) { throw std::runtime_error(&#34;Key not found&#34;); } return *result; } const Val &amp;search(const Key &amp;k) const { Val *result = _search(root, k); if (result == nullptr) { throw std::runtime_error(&#34;Key not found&#34;); } return *result; } bool contains(const Key &amp;k) { return _search(root, k) != nullptr; } void inorder_vector(std::vector&lt;std::pair&lt;Key, Val&gt;&gt; &amp;v) const { v.clear(); _inorder(root, v); } int height() const { return _height; } int last_insert_splits() const { return split_counter; } void clear() { _clear(root); root = new Node(true); _size = 0; } // NOTE: only used for testing the actual height // computation dont use this, it&#39;s super naive int _height_naive() { return _height_naive(root); } }; " />
<meta name="keywords" content=", " />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://matteodegobbi.github.io/posts/prova_codice/" />





  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="https://matteodegobbi.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="https://matteodegobbi.github.io/favicon.png">
<link rel="apple-touch-icon" href="https://matteodegobbi.github.io/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Prova_codice">
<meta property="og:description" content=" #pragma once #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;stdexcept&gt; #include &lt;utility&gt; #include &lt;vector&gt; template &lt;typename Key, typename Val, int M&gt; class BTree { // M is the minimum degree of the B-tree. // Max keys in a node: 2*M - 1 // Min keys in a non-root node: M - 1 private: struct Node { bool is_leaf; std::vector&lt;Key&gt; keys; std::vector&lt;Val&gt; vals; std::vector&lt;Node *&gt; children; Node(bool leaf = false) : is_leaf(leaf) {} // NOTE: destructor called recursively ~Node() { for (Node *child : children) { delete child; } } }; Node *root = nullptr; int _size = 0; int _height = 0; int split_counter = 0; void _clear(Node *node) { if (node != nullptr) { delete node; // The destructor of sruct Node deletes children recursively } } // NOTE: Functions for search in this section Val *_search(Node *node, const Key &amp;k) { if (node == nullptr) { return nullptr; } // STL binary search to get first element &gt;= to k auto it = std::lower_bound(node-&gt;keys.begin(), node-&gt;keys.end(), k); // get index from iterator int i = std::distance(node-&gt;keys.begin(), it); // found k if (it != node-&gt;keys.end() &amp;&amp; *it == k) { return &amp;node-&gt;vals[i]; } if (node-&gt;is_leaf) { return nullptr; } return _search(node-&gt;children[i], k); } // NOTE: Functions for insertion in this section // // splits the child at `parent-&gt;children[child_index]` void _split_child(Node *parent, int child_index) { split_counter&#43;&#43;; Node *child_to_split = parent-&gt;children[child_index]; // create new sibling for splitting the node in half Node *new_child = new Node(child_to_split-&gt;is_leaf); // Promote the median key and value to the parent node parent-&gt;keys.insert(parent-&gt;keys.begin() &#43; child_index, child_to_split-&gt;keys[M - 1]); parent-&gt;vals.insert(parent-&gt;vals.begin() &#43; child_index, child_to_split-&gt;vals[M - 1]); // Put the sibling as a child of the parent // It will be the sibling to the right of the split node parent-&gt;children.insert(parent-&gt;children.begin() &#43; child_index &#43; 1, new_child); // move half of keys and values to the split node&#39;s sibling new_child-&gt;keys.assign(child_to_split-&gt;keys.begin() &#43; M, child_to_split-&gt;keys.end()); new_child-&gt;vals.assign(child_to_split-&gt;vals.begin() &#43; M, child_to_split-&gt;vals.end()); child_to_split-&gt;keys.resize(M - 1); child_to_split-&gt;vals.resize(M - 1); // if the split node was not a leaf, move its children into its new sibling if (!child_to_split-&gt;is_leaf) { new_child-&gt;children.assign(child_to_split-&gt;children.begin() &#43; M, child_to_split-&gt;children.end()); child_to_split-&gt;children.resize(M); } } // NOTE: IMPORTANT INVARIANT node should not be already full // otherwise it will overflow, only call this from public method void _insert_rec(Node *node, const Key &amp;k, const Val &amp;v) { // STL binary search to get index of first key &gt;= k auto it = std::lower_bound(node-&gt;keys.begin(), node-&gt;keys.end(), k); int i = std::distance(node-&gt;keys.begin(), it); // get index in vector of iterator it if (node-&gt;is_leaf) { // case where we found already existing key, update the val if (it != node-&gt;keys.end() &amp;&amp; *it == k) { node-&gt;vals[i] = v; return; } // regular case just insert the key in the leaf node-&gt;keys.insert(it, k); node-&gt;vals.insert(node-&gt;vals.begin() &#43; i, v); _size&#43;&#43;; } else { // case where we found already existing key, update the val, same as in // leaf if (it != node-&gt;keys.end() &amp;&amp; *it == k) { node-&gt;vals[i] = v; return; } // NOTE: important, guarantees that no node will overflow // splits the child we will visit recursively in case // it&#39;s already full if (node-&gt;children[i]-&gt;keys.size() == 2 * M - 1) { _split_child(node, i); // increase variabile i in case i need to go to the new sibling after // the split if (k &gt; node-&gt;keys[i]) { i&#43;&#43;; } } _insert_rec(node-&gt;children[i], k, v); } } // NOTE: Functions for deletion in this section std::pair&lt;Key, Val&gt; _get_pred(Node *node, int i) { Node *cur = node-&gt;children[i]; while (!cur-&gt;is_leaf) { cur = cur-&gt;children.back(); } return {cur-&gt;keys.back(), cur-&gt;vals.back()}; } std::pair&lt;Key, Val&gt; _get_succ(Node *node, int i) { Node *cur = node-&gt;children[i &#43; 1]; while (!cur-&gt;is_leaf) { cur = cur-&gt;children.front(); } return {cur-&gt;keys.front(), cur-&gt;vals.front()}; } void _borrow_from_prev(Node *node, int i) { Node *child = node-&gt;children[i]; Node *sibling = node-&gt;children[i - 1]; // take key from parent child-&gt;keys.insert(child-&gt;keys.begin(), node-&gt;keys[i - 1]); child-&gt;vals.insert(child-&gt;vals.begin(), node-&gt;vals[i - 1]); // eventually add children inherited from key taken from parent if (!child-&gt;is_leaf) { child-&gt;children.insert(child-&gt;children.begin(), sibling-&gt;children.back()); sibling-&gt;children.pop_back(); } node-&gt;keys[i - 1] = sibling-&gt;keys.back(); node-&gt;vals[i - 1] = sibling-&gt;vals.back(); sibling-&gt;keys.pop_back(); sibling-&gt;vals.pop_back(); } void _borrow_from_next(Node *node, int i) { Node *child = node-&gt;children[i]; Node *sibling = node-&gt;children[i &#43; 1]; child-&gt;keys.push_back(node-&gt;keys[i]); child-&gt;vals.push_back(node-&gt;vals[i]); if (!child-&gt;is_leaf) { child-&gt;children.push_back(sibling-&gt;children.front()); sibling-&gt;children.erase(sibling-&gt;children.begin()); } node-&gt;keys[i] = sibling-&gt;keys.front(); node-&gt;vals[i] = sibling-&gt;vals.front(); sibling-&gt;keys.erase(sibling-&gt;keys.begin()); sibling-&gt;vals.erase(sibling-&gt;vals.begin()); } void _merge(Node *node, int i) { Node *child = node-&gt;children[i]; Node *sibling = node-&gt;children[i &#43; 1]; child-&gt;keys.push_back(node-&gt;keys[i]); child-&gt;vals.push_back(node-&gt;vals[i]); child-&gt;keys.insert(child-&gt;keys.end(), sibling-&gt;keys.begin(), sibling-&gt;keys.end()); child-&gt;vals.insert(child-&gt;vals.end(), sibling-&gt;vals.begin(), sibling-&gt;vals.end()); if (!child-&gt;is_leaf) { child-&gt;children.insert(child-&gt;children.end(), sibling-&gt;children.begin(), sibling-&gt;children.end()); sibling-&gt;children.clear(); // Important: prevent double deletion } node-&gt;keys.erase(node-&gt;keys.begin() &#43; i); node-&gt;vals.erase(node-&gt;vals.begin() &#43; i); node-&gt;children.erase(node-&gt;children.begin() &#43; i &#43; 1); delete sibling; } void _fill(Node *node, int i) { // if i can borrow from left sibling if (i != 0 &amp;&amp; node-&gt;children[i - 1]-&gt;keys.size() &gt;= M) { _borrow_from_prev(node, i); // if i can borrow from right sibling } else if (i != node-&gt;keys.size() &amp;&amp; node-&gt;children[i &#43; 1]-&gt;keys.size() &gt;= M) { _borrow_from_next(node, i); // if i cannot borrow i need to merge the siblings into a node } else { if (i != node-&gt;keys.size()) { _merge(node, i); } else { _merge(node, i - 1); } } } void _remove_in_leaf(Node *node, int i) { node-&gt;keys.erase(node-&gt;keys.begin() &#43; i); node-&gt;vals.erase(node-&gt;vals.begin() &#43; i); _size--; } void _remove_in_internal(Node *node, int i) { Key k = node-&gt;keys[i]; if (node-&gt;children[i]-&gt;keys.size() &gt;= M) { auto [pred_key, pred_val] = _get_pred(node, i); node-&gt;keys[i] = pred_key; node-&gt;vals[i] = pred_val; _remove(node-&gt;children[i], pred_key); } else if (node-&gt;children[i &#43; 1]-&gt;keys.size() &gt;= M) { auto [succ_key, succ_val] = _get_succ(node, i); node-&gt;keys[i] = succ_key; node-&gt;vals[i] = succ_val; _remove(node-&gt;children[i &#43; 1], succ_key); } else { _merge(node, i); _remove(node-&gt;children[i], k); } } void _remove(Node *node, const Key &amp;k) { // STL binary search to get index of first key &gt;= k auto it = std::lower_bound(node-&gt;keys.begin(), node-&gt;keys.end(), k); int i = std::distance(node-&gt;keys.begin(), it); if (i &lt; node-&gt;keys.size() &amp;&amp; node-&gt;keys[i] == k) { if (node-&gt;is_leaf) { _remove_in_leaf(node, i); } else { _remove_in_internal(node, i); } } else { if (node-&gt;is_leaf) { return; // key not found nothing is removed } bool is_last_child = (i == node-&gt;keys.size()); // to keep invariant about minimum number of keys // in a node is &gt;= M-1 if (node-&gt;children[i]-&gt;keys.size() &lt; M) { _fill(node, i); } if (is_last_child &amp;&amp; i &gt; node-&gt;keys.size()) { _remove(node-&gt;children[i - 1], k); } else { _remove(node-&gt;children[i], k); } } } // NOTE: other functions not related to search, insertio and removal in this // section void _inorder(Node *node, std::vector&lt;std::pair&lt;Key, Val&gt;&gt; &amp;v) const { if (node == nullptr) return; int i; for (i = 0; i &lt; node-&gt;keys.size(); i&#43;&#43;) { if (!node-&gt;is_leaf) { _inorder(node-&gt;children[i], v); } v.push_back(std::make_pair(node-&gt;keys[i], node-&gt;vals[i])); } if (!node-&gt;is_leaf) { _inorder(node-&gt;children[i], v); } } // NOTE: only used for testing the actual height // computation dont use this, it&#39;s super naive int _height_naive(Node *node) const { if (node == nullptr) { return -1; } if (node-&gt;is_leaf) { return 0; } int max_child_height = -1; for (Node *child : node-&gt;children) { int child_height = _height_naive(child); max_child_height = std::max(max_child_height, child_height); } return 1 &#43; max_child_height; } public: BTree() { root = new Node(true); } ~BTree() { _clear(root); } int size() const { return _size; } bool empty() const { return _size == 0; } void insert(const Key &amp;k, const Val &amp;v) { split_counter = 0; Node *r = root; // if root is full make a new one with old root as child if (r-&gt;keys.size() == 2 * M - 1) { Node *s = new Node(); root = s; s-&gt;children.push_back(r); _split_child(s, 0); &#43;&#43;_height; _insert_rec(s, k, v); } else { _insert_rec(r, k, v); } } void remove(const Key &amp;k) { if (!root) { return; } _remove(root, k); // NOTE: case where we need to shrink tree height by 1 if (root-&gt;keys.empty() &amp;&amp; !root-&gt;is_leaf) { Node *old_root = root; root = root-&gt;children[0]; old_root-&gt;children .clear(); // Prevent destructor from deleting the new root delete old_root; --_height; } } Val &amp;search(const Key &amp;k) { Val *result = _search(root, k); if (result == nullptr) { throw std::runtime_error(&#34;Key not found&#34;); } return *result; } const Val &amp;search(const Key &amp;k) const { Val *result = _search(root, k); if (result == nullptr) { throw std::runtime_error(&#34;Key not found&#34;); } return *result; } bool contains(const Key &amp;k) { return _search(root, k) != nullptr; } void inorder_vector(std::vector&lt;std::pair&lt;Key, Val&gt;&gt; &amp;v) const { v.clear(); _inorder(root, v); } int height() const { return _height; } int last_insert_splits() const { return split_counter; } void clear() { _clear(root); root = new Node(true); _size = 0; } // NOTE: only used for testing the actual height // computation dont use this, it&#39;s super naive int _height_naive() { return _height_naive(root); } }; " />
<meta property="og:url" content="https://matteodegobbi.github.io/posts/prova_codice/" />
<meta property="og:site_name" content="Matteo Site" />

  
  
  <meta property="og:image" content="https://matteodegobbi.github.io/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-06-13 23:34:39 &#43;0200 CEST" />












</head>
<body>


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://matteodegobbi.github.io/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
    
  </div>
  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://matteodegobbi.github.io/posts/prova_codice/">Prova_codice</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-06-13</time></div>

  
    <span class="post-tags">
      
      #<a href="https://matteodegobbi.github.io/tags/"></a>&nbsp;
      
      #<a href="https://matteodegobbi.github.io/tags/"></a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma once
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdexcept&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Key, <span style="color:#66d9ef">typename</span> Val, <span style="color:#66d9ef">int</span> M<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BTree</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// M is the minimum degree of the B-tree.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Max keys in a node: 2*M - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Min keys in a non-root node: M - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> is_leaf;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span> keys;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Val<span style="color:#f92672">&gt;</span> vals;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Node <span style="color:#f92672">*&gt;</span> children;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node(<span style="color:#66d9ef">bool</span> leaf <span style="color:#f92672">=</span> false) <span style="color:#f92672">:</span> is_leaf(leaf) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// NOTE: destructor called recursively
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>Node() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> (Node <span style="color:#f92672">*</span>child : children) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> child;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Node <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> _size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> _height <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> split_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_clear</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">delete</span> node; <span style="color:#75715e">// The destructor of sruct Node deletes children recursively
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: Functions for search in this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  Val <span style="color:#f92672">*</span><span style="color:#a6e22e">_search</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// STL binary search to get first element &gt;= to k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(node<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys.end(), k);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get index from iterator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(node<span style="color:#f92672">-&gt;</span>keys.begin(), it);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// found k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.end() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>node<span style="color:#f92672">-&gt;</span>vals[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> _search(node<span style="color:#f92672">-&gt;</span>children[i], k);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: Functions for insertion in this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// splits the child at `parent-&gt;children[child_index]`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_split_child</span>(Node <span style="color:#f92672">*</span>parent, <span style="color:#66d9ef">int</span> child_index) {
</span></span><span style="display:flex;"><span>    split_counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child_to_split <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>children[child_index];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// create new sibling for splitting the node in half
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>new_child <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(child_to_split<span style="color:#f92672">-&gt;</span>is_leaf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Promote the median key and value to the parent node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">-&gt;</span>keys.insert(parent<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> child_index,
</span></span><span style="display:flex;"><span>                        child_to_split<span style="color:#f92672">-&gt;</span>keys[M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    parent<span style="color:#f92672">-&gt;</span>vals.insert(parent<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> child_index,
</span></span><span style="display:flex;"><span>                        child_to_split<span style="color:#f92672">-&gt;</span>vals[M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Put the sibling as a child of the parent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// It will be the sibling  to the right of the split node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">-&gt;</span>children.insert(parent<span style="color:#f92672">-&gt;</span>children.begin() <span style="color:#f92672">+</span> child_index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                            new_child);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// move half of keys and values to the split node&#39;s sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    new_child<span style="color:#f92672">-&gt;</span>keys.assign(child_to_split<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> M,
</span></span><span style="display:flex;"><span>                           child_to_split<span style="color:#f92672">-&gt;</span>keys.end());
</span></span><span style="display:flex;"><span>    new_child<span style="color:#f92672">-&gt;</span>vals.assign(child_to_split<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> M,
</span></span><span style="display:flex;"><span>                           child_to_split<span style="color:#f92672">-&gt;</span>vals.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child_to_split<span style="color:#f92672">-&gt;</span>keys.resize(M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    child_to_split<span style="color:#f92672">-&gt;</span>vals.resize(M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if the split node was not a leaf, move its children into its new sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child_to_split<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      new_child<span style="color:#f92672">-&gt;</span>children.assign(child_to_split<span style="color:#f92672">-&gt;</span>children.begin() <span style="color:#f92672">+</span> M,
</span></span><span style="display:flex;"><span>                                 child_to_split<span style="color:#f92672">-&gt;</span>children.end());
</span></span><span style="display:flex;"><span>      child_to_split<span style="color:#f92672">-&gt;</span>children.resize(M);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: IMPORTANT INVARIANT node should not be already full
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// otherwise it will overflow, only call this from public method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_insert_rec</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">const</span> Val <span style="color:#f92672">&amp;</span>v) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// STL binary search to get index of first key &gt;= k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(node<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys.end(), k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(node<span style="color:#f92672">-&gt;</span>keys.begin(),
</span></span><span style="display:flex;"><span>                          it); <span style="color:#75715e">// get index in vector of iterator it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// case where we found already existing key, update the val
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.end() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// regular case just insert the key in the leaf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      node<span style="color:#f92672">-&gt;</span>keys.insert(it, k);
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>vals.insert(node<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> i, v);
</span></span><span style="display:flex;"><span>      _size<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// case where we found already existing key, update the val, same as in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// leaf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.end() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// NOTE: important, guarantees that no node will overflow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// splits the child we will visit recursively in case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// it&#39;s already full
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        _split_child(node, i);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// increase variabile i in case i need to go to the new sibling after
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// the split
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>keys[i]) {
</span></span><span style="display:flex;"><span>          i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      _insert_rec(node<span style="color:#f92672">-&gt;</span>children[i], k, v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: Functions for deletion in this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;</span> _get_pred(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>cur<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>children.back();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {cur<span style="color:#f92672">-&gt;</span>keys.back(), cur<span style="color:#f92672">-&gt;</span>vals.back()};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;</span> _get_succ(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>cur<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>children.front();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {cur<span style="color:#f92672">-&gt;</span>keys.front(), cur<span style="color:#f92672">-&gt;</span>vals.front()};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_borrow_from_prev</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>sibling <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// take key from parent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    child<span style="color:#f92672">-&gt;</span>keys.insert(child<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.insert(child<span style="color:#f92672">-&gt;</span>vals.begin(), node<span style="color:#f92672">-&gt;</span>vals[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// eventually add children inherited from key taken from parent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      child<span style="color:#f92672">-&gt;</span>children.insert(child<span style="color:#f92672">-&gt;</span>children.begin(), sibling<span style="color:#f92672">-&gt;</span>children.back());
</span></span><span style="display:flex;"><span>      sibling<span style="color:#f92672">-&gt;</span>children.pop_back();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>keys.back();
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>vals.back();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>keys.pop_back();
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>vals.pop_back();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_borrow_from_next</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>sibling <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>keys.push_back(node<span style="color:#f92672">-&gt;</span>keys[i]);
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.push_back(node<span style="color:#f92672">-&gt;</span>vals[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      child<span style="color:#f92672">-&gt;</span>children.push_back(sibling<span style="color:#f92672">-&gt;</span>children.front());
</span></span><span style="display:flex;"><span>      sibling<span style="color:#f92672">-&gt;</span>children.erase(sibling<span style="color:#f92672">-&gt;</span>children.begin());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>keys.front();
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> sibling<span style="color:#f92672">-&gt;</span>vals.front();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>keys.erase(sibling<span style="color:#f92672">-&gt;</span>keys.begin());
</span></span><span style="display:flex;"><span>    sibling<span style="color:#f92672">-&gt;</span>vals.erase(sibling<span style="color:#f92672">-&gt;</span>vals.begin());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_merge</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i];
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>sibling <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>keys.push_back(node<span style="color:#f92672">-&gt;</span>keys[i]);
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.push_back(node<span style="color:#f92672">-&gt;</span>vals[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>keys.insert(child<span style="color:#f92672">-&gt;</span>keys.end(), sibling<span style="color:#f92672">-&gt;</span>keys.begin(),
</span></span><span style="display:flex;"><span>                       sibling<span style="color:#f92672">-&gt;</span>keys.end());
</span></span><span style="display:flex;"><span>    child<span style="color:#f92672">-&gt;</span>vals.insert(child<span style="color:#f92672">-&gt;</span>vals.end(), sibling<span style="color:#f92672">-&gt;</span>vals.begin(),
</span></span><span style="display:flex;"><span>                       sibling<span style="color:#f92672">-&gt;</span>vals.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>child<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      child<span style="color:#f92672">-&gt;</span>children.insert(child<span style="color:#f92672">-&gt;</span>children.end(), sibling<span style="color:#f92672">-&gt;</span>children.begin(),
</span></span><span style="display:flex;"><span>                             sibling<span style="color:#f92672">-&gt;</span>children.end());
</span></span><span style="display:flex;"><span>      sibling<span style="color:#f92672">-&gt;</span>children.clear(); <span style="color:#75715e">// Important: prevent double deletion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys.erase(node<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals.erase(node<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>children.erase(node<span style="color:#f92672">-&gt;</span>children.begin() <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> sibling;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_fill</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if i can borrow from left sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      _borrow_from_prev(node, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if i can borrow from right sibling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>               node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      _borrow_from_next(node, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if i cannot borrow i need to merge the siblings into a node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> node<span style="color:#f92672">-&gt;</span>keys.size()) {
</span></span><span style="display:flex;"><span>        _merge(node, i);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        _merge(node, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_remove_in_leaf</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>keys.erase(node<span style="color:#f92672">-&gt;</span>keys.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>vals.erase(node<span style="color:#f92672">-&gt;</span>vals.begin() <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>    _size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_remove_in_internal</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    Key k <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>keys[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">auto</span> [pred_key, pred_val] <span style="color:#f92672">=</span> _get_pred(node, i);
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">=</span> pred_key;
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> pred_val;
</span></span><span style="display:flex;"><span>      _remove(node<span style="color:#f92672">-&gt;</span>children[i], pred_key);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&gt;=</span> M) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">auto</span> [succ_key, succ_val] <span style="color:#f92672">=</span> _get_succ(node, i);
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">=</span> succ_key;
</span></span><span style="display:flex;"><span>      node<span style="color:#f92672">-&gt;</span>vals[i] <span style="color:#f92672">=</span> succ_val;
</span></span><span style="display:flex;"><span>      _remove(node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], succ_key);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      _merge(node, i);
</span></span><span style="display:flex;"><span>      _remove(node<span style="color:#f92672">-&gt;</span>children[i], k);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_remove</span>(Node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// STL binary search to get index of first key &gt;= k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(node<span style="color:#f92672">-&gt;</span>keys.begin(), node<span style="color:#f92672">-&gt;</span>keys.end(), k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(node<span style="color:#f92672">-&gt;</span>keys.begin(), it);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>keys[i] <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>        _remove_in_leaf(node, i);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        _remove_in_internal(node, i);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// key not found nothing is removed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">bool</span> is_last_child <span style="color:#f92672">=</span> (i <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>keys.size());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// to keep invariant about minimum number of keys
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// in a node is &gt;= M-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>children[i]<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">&lt;</span> M) {
</span></span><span style="display:flex;"><span>        _fill(node, i);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (is_last_child <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>keys.size()) {
</span></span><span style="display:flex;"><span>        _remove(node<span style="color:#f92672">-&gt;</span>children[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], k);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        _remove(node<span style="color:#f92672">-&gt;</span>children[i], k);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: other functions not related to search, insertio and removal in this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_inorder</span>(Node <span style="color:#f92672">*</span>node, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span>v) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>keys.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>        _inorder(node<span style="color:#f92672">-&gt;</span>children[i], v);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      v.push_back(std<span style="color:#f92672">::</span>make_pair(node<span style="color:#f92672">-&gt;</span>keys[i], node<span style="color:#f92672">-&gt;</span>vals[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      _inorder(node<span style="color:#f92672">-&gt;</span>children[i], v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: only used for testing the actual height
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// computation dont use this, it&#39;s super naive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_height_naive</span>(Node <span style="color:#f92672">*</span>node) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> max_child_height <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (Node <span style="color:#f92672">*</span>child : node<span style="color:#f92672">-&gt;</span>children) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> child_height <span style="color:#f92672">=</span> _height_naive(child);
</span></span><span style="display:flex;"><span>      max_child_height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(max_child_height, child_height);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max_child_height;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  BTree() { root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(true); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">~</span>BTree() { _clear(root); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _size; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">const</span> Val <span style="color:#f92672">&amp;</span>v) {
</span></span><span style="display:flex;"><span>    split_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if root is full make a new one with old root as child
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (r<span style="color:#f92672">-&gt;</span>keys.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> M <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>      Node <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node();
</span></span><span style="display:flex;"><span>      root <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>      s<span style="color:#f92672">-&gt;</span>children.push_back(r);
</span></span><span style="display:flex;"><span>      _split_child(s, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">++</span>_height;
</span></span><span style="display:flex;"><span>      _insert_rec(s, k, v);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      _insert_rec(r, k, v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _remove(root, k);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// NOTE: case where we need to shrink tree height by 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>keys.empty() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>root<span style="color:#f92672">-&gt;</span>is_leaf) {
</span></span><span style="display:flex;"><span>      Node <span style="color:#f92672">*</span>old_root <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>      root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>children[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>      old_root<span style="color:#f92672">-&gt;</span>children
</span></span><span style="display:flex;"><span>          .clear(); <span style="color:#75715e">// Prevent destructor from deleting the new root
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">delete</span> old_root;
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">--</span>_height;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Val <span style="color:#f92672">&amp;</span>search(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) {
</span></span><span style="display:flex;"><span>    Val <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> _search(root, k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(<span style="color:#e6db74">&#34;Key not found&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Val <span style="color:#f92672">&amp;</span>search(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    Val <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> _search(root, k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(<span style="color:#e6db74">&#34;Key not found&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contains</span>(<span style="color:#66d9ef">const</span> Key <span style="color:#f92672">&amp;</span>k) { <span style="color:#66d9ef">return</span> _search(root, k) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inorder_vector</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Val<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span>v) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    v.clear();
</span></span><span style="display:flex;"><span>    _inorder(root, v);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">height</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _height; }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">last_insert_splits</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> split_counter; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clear</span>() {
</span></span><span style="display:flex;"><span>    _clear(root);
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(true);
</span></span><span style="display:flex;"><span>    _size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NOTE: only used for testing the actual height
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// computation dont use this, it&#39;s super naive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_height_naive</span>() { <span style="color:#66d9ef">return</span> _height_naive(root); }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>
      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
