[{"content":"Producer-Consumer problem with dynamic rate adjustment In this repo I implemented the producer consumer problem with dynamic rate adjustment carried out with an actor.\nThe consumer is a thread that consumes messages at a given fixed rate, that is, with a given delay from a shared buffer, simulating the consumed message usage. The producer is a thread that creates messages and writes them to a shared buffer, the rate of the producer is controlled by another thread called the actor.\nAn actor separate from producer and consumer periodically checks the message queue length and if the length is below a given threshold, it will increase the production rate. Otherwise (i.e. the message length is above the given threshold), it will decrease the production rate. In this case the message queue is implemented with a circular queue (or ring buffer).\nThe main idea is to try to keep the buffer always half-full. Meaning the objective is to have buffer utilization always close to 50%, this leaves room in both ways: if the consumer is delayed we will still have room for inserting new data, and if the producer is delayed we still have data to consume for a while. This way it maximizes the production rate until the buffer utilization goes over 50%. Any other threshold could be chosen and the program still works (e.g. I tried also with 70%).\nI tried two approaches, both inspired by control systems, the control is carried out by changing a delay in the producer thread, this will dynamically adjust the rate of the producer to try to keep the buffer utilization at 50%.\nThe two controllers are:\nA simple threshold based control system A PID controller Both systems share the code for the producer and the consumer. The actor that carries out the control is different in the two solutions. In both cases the actor runs at a fixed rate (e.g. every 1ms or 0.5ms etc.) and it checks the current buffer utilization, it then uses this information to adjust the producer\u0026rsquo;s rate. More information about the two methods will be given below.\nIt\u0026rsquo;s important to have the actor\u0026rsquo;s rate not too high or too low. If the delay is too high then the actor does not have time to react to changes in buffer utilization, leading to oscillations between the buffer being too full and too empty. Inversely if the delay is too small the actor will enter the critical section too often, making the producer and consumer wait to enter their critical section and degrading the perfomance of the two.\nUnfortunately we cannot fix a rate for the actor for every task and every system and this will need to be tuned depending on the system used.\nAnother important detail is the length of the buffer: if the buffer is too small and the producer (or consumer) is carrying out some operation, the other thread will empty (or fill) the buffer and we don\u0026rsquo;t have enough room to provide some leeway for the two threads to do their work while the other one is waiting or performing some other operations, hampering the concurrency of the system. In most of my experiments I tried buffer sizes of 100000 and 1000000. This problem can be witnessed with a buffer size of just 1000 or 100 the buffer utilization oscillates between 0% and 100%. The buffer length also influences at what rate we can run the actor, a bigger buffer allows us to run the actor less often, meaning the actor adds less overhead to the system.\nControl methods In this section I explain the two methods I implemented to try to maximize the production rate while keeping the buffer utilization under 50%.\nNaive threshold based method The first method I implemented is called naive_actor in the code and it loops over the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 pthread_mutex_lock(\u0026amp;mutex); int count = (writeIdx - readIdx + buffer_size) % buffer_size; float percent = (float)count / (float)buffer_size; if (percent \u0026lt; 0.45) { producer_delay *= 0.8; producer_delay += 1; // to avoid having delay==0 } else if (percent \u0026gt; 0.55) { producer_delay *= 1.2; } producer_delay = producer_delay \u0026gt; 1e6 ? 1e6 : producer_delay; // clip if above 1s int last_delay = (int)producer_delay; pthread_mutex_unlock(\u0026amp;mutex); this is a very simple implementation that just check whether the percent utilization of the buffer has gone above 55% or below 45% and decreases or increases the producer\u0026rsquo;s rate by 20%. This approach is similar to bang-bang control in control theory since it only activates when it\u0026rsquo;s between two thresholds, in this case the output is like a binary on/off that either increases or decreases the delay by 20% independently of how far the buffer utilization is from 50%.\nThe producer delay is clipped to be 1 second at most, this is not necessary with the normal setup with fixed consumer delay but later I will explain a variation I tried where the consumer\u0026rsquo;s delay is generated by a Cauchy random variable and in this case this naive controller can be unstable and create high delays above 1 second in the producer.\nWhen using the PID controller that I will explain later, this step is not needed, because even when the consumer\u0026rsquo;s delay is generated by a Cauchy r.v. the system is still stable without clipping.\nIn the figure below we can see how the naive controller performs, the buffer utilization reaches 50%, then it overshoots to ~57% and then starts oscillating between ~43% and ~57%, this is expected for two reasons:\nThe controller only works if the utilization goes outside the range [0.45,0.55], When it changes the delay it only reacts by changing it by a fixed percentage of the previous value. It does not use the distance from the target utilization or the rate of change of the error, meaning if the current utilization is 56% it will react in the same way if the previous utilization was 55% or if it was 90%. But it should react differently, if the previous utilization was 56% and it\u0026rsquo;s still 56% we probably need to increase the delay, but if it was 90% it means the consumer has increased its speed for whatever reason so we probably won\u0026rsquo;t need to increase the delay. This 2nd point made me think if I can incorporate in some way the rate of change, and at this point I realized that I can use a PID controller, this way I can use the rate of change through the derivative and I can also tune the parameters more easily, since I just need to change 3 numbers. Also using a PID controller the proportional term will be proportional to the error reacting differently if the error is small or large, the naive controller always reacts at the same speed independently from the magnitude of the error.\nFigure 1: Buffer utilization percentage and producer's delay when using the naive controller PID controller To implement the PID controller I changed the actor code and made the function pid_actor which changes the main loop to this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 float prev_error = 0.0; float integral = 0.0; while (keep_running) { pthread_mutex_lock(\u0026amp;mutex); int count = (writeIdx - readIdx + buffer_size) % buffer_size; float percent = (float)count / (float)buffer_size; float error = 0.50 - percent; integral += error; float derivative = (error - prev_error); float output = k_p * error + k_d * derivative + k_i * integral; prev_error = error; producer_delay = producer_delay - (int)(output); producer_delay = producer_delay \u0026lt; 0 ? 0 : producer_delay; // clip if below 0 int last_delay = producer_delay; pthread_mutex_unlock(\u0026amp;mutex); // write buffer utilization and producer delay rate fprintf(fp, \u0026#34;%.2f,%d\\n\u0026#34;, percent, last_delay); usleep(ACTOR_DELAY); } The actor computes the error as the difference between the 0.50 (the wanted buffer utilization) and the current buffer utilization. Then this error is used to compute the output of the controller that will be subtracted from the current delay in a feedback loop. We have that the output is made up of three terms:\nProportional term which is proportional to the error itself, this is similar to the naive controller Integrative term, which means proportional to the sum of past errors Derivative term, meaning proportional to the difference between the current and previous error. (This is the part that incorporates the rate of change) The multiplicative constants K_p,K_i,K_d are read from a configuration file.\nIn this case we don\u0026rsquo;t need to clip the delay to be below one second as the system is already stable, but we do need to clip it to not go below 0 as a negative delay makes no sense.\nThis PID actor works much better without oscillations and it just requires to try a few combinations of the parameters to work. Some values of K_p,K_i,K_d I found that work well are 1000,0,1000, 1000,0,10000 or 10000,0,10000.\nThe constant K_d of the derivative term has the effect of dampening oscillations and overshoots, but if it\u0026rsquo;s increased too much it can make the system too slow to react to changes of regimes and to initially reach the 50% utilization.\nI found that the integral term is usually not needed as there isn\u0026rsquo;t a drift in time from the wanted output. The only set of parameters I found an instance in which the integral term helps: with K_p=100,K_d=10000 the system has a small steady state error so adding a small integral term of K_i=0.01 removes this steady state error at the cost of some oscillation. Since this steady state error can also be removed by increasing K_p without introducing oscillations I never wound up using the integral term but I left it implemented because in some systems it could be useful to counteract systemic noise.\nThis example of adding the effect of adding K_i=0.01 can be seen in the figure below.\nFigure 2a: Buffer utilization percentage with PID controller and Kp=100,Ki=0,Kd=10000. We can notice that the steady state of utilization is slightly above 50%, around 51% and no oscillation occurs. Figure 2b: Buffer utilization percentage with PID controller and Kp=100,Ki=0.01,Kd=10000. We can notice that the utilization oscillates around 50%. Figure 2c: Buffer utilization percentage with PID controller and Kp=1000,Ki=0,Kd=10000, the system quickly reaches 50% utilization and does not oscillate. Below I will show some plots when using the PID controller with different constants.\nFirsty let\u0026rsquo;s see with just a proportional controller:\nFigure 3: Buffer utilization percentage and producer's delay when using the PID controller with Kp=100,Ki=00,Kd=0, we have oscillations in both the utilization and the producer delay Since with just a proportional controller like in the previous figure there are oscillations we can try to add a derivative term to try to dampen the oscillations:\nFigure 4: Buffer utilization percentage and producer's delay when using the PID controller with Kp=100,Ki=0,Kd=1000, the oscillations decrease in magnitude over time. Eventually the producer's delay matches the consumer's. We can now try to increase Kp and/or Kd to try to see if we can get better outcomes in terms of reaching steady state faster and reducing overshoot and oscillations:\nFigure 5: Buffer utilization percentage and producer's delay when using the PID controller with Kp=1000,Ki=0,Kd=1000, the overshoot is decreased and the systems reaches steady state quickly, still there are oscillations in the producer's delay. To try to reduce the oscillations in the producer\u0026rsquo;s delay I finally increased both Kp and Kd to make the system settle fast but also reduce the oscillations in the controlling signal.\nFigure 6: Buffer utilization percentage and producer's delay when using the PID controller with Kp=10000,Ki=0,Kd=10000, the utilization doesn't overshoot and reaches steady state quickly, the oscillations in the producer's delay happen only at the beginning and quickly go away. Variable rate consumer using Cauchy distributed random delay Finally I decided to see if the two systems can deal with a consumer that has a very variable rate, to do this is decided to generate the delay of the consumer with a Cauchy random variable with center 100 and scale parameter 100.\nI choose a Cauchy rv because it has very high variability and is unpredictable, the median of this delay will still be 100 microseconds but much higher delays can be generated, still I clipped the delay to not be more than 1e6 microseconds (1 second) to avoid very long wait times.\nJust to see how variable this delay is we can run this R script:\n1 2 3 4 5 6 x_gaussian = rnorm(mean=100,sd=100,n=1000) x_cauchy = rcauchy(100,100,1000) print(median(x_gaussian)) print(median(x_cauchy)) print(max(x_gaussian)) print(max(x_cauchy)) with a run of this script we get that the medians are 107.7077 for the gaussian and 106.806 for the Cauchy. But the maxes are very different: 475.0348 for the gaussian and 55947.0 for the Cauchy. And this is with only 1000 samples, increasing the number of samples would highlight the difference even further as Cauchy r.v.\u0026rsquo;s don\u0026rsquo;t have a finite variance.\nSo the system needs to be able to act quickly in order to counteract this kind of spikes in delays.\nNow I will show some plots overviewing the behaviour of the two controllers when dealing with this Cauchy delay.\nFigure 7: Buffer utilization percentage and producer's delay when using the naive controller, the consumer's delay is generated by a Cauchy r.v. Figure 8: Buffer utilization percentage and producer's delay when using the PID controller with Kp=10000,Ki=0,Kd=10000, the consumer's delay is generated by a Cauchy r.v. As we can see from the previous Figures 7 and 8 the two controllers exhibit very different behaviours. The naive controller goes from delay 0 to 10 seconds of delay (this is the reason why after I added the clipping to 1 second) in some systems (e.g. my laptop) this is very drastic and can hang the system for a long time, the buffer utilization is always between 40% and 60% but it\u0026rsquo;s more unstable.\nWith the same setup the PID controller is much more stable having spikes only when the consumer has a long delay and quickly reaching 50% again by adjusting the producer rate. The controller also doesn\u0026rsquo;t reach very long delays as it can respond in a more stable manner, reaching at most 60000 microseconds delay against 1e7 microseconds (or more) of the naive controller.\nHow to run the experiments You need to have installed gcc and make in a POSIX compatible machine with pthreads (I tested the code on Ubuntu 24.04 LTS on a x86 machine and MacOS Sequoia 15.5 on a ARM machine)\nFor the plotting you need to have installed python with the libraries pandas and matplotlib.\nTo run the experiment you can set the PID constants in the text config file pid_constants.txt and run\n1 2 3 4 # to run with fixed delay make run-and-plot MODE=1 # to run with Cauchy delay make cauchy-run-and-plot MODE=1 The MODE argument when set to 1 (default value) runs with the PID controller and when set to 0 runs with the naive controller.\nTo set the durations of the experiment or the buffer size you can change the Makefile.\n","date":"2025-08-02T18:19:21+02:00","image":"https://matteodegobbi.github.io/example_plots/fixed_delay/pid_1000_1000/prod_delay.png","permalink":"https://matteodegobbi.github.io/p/dynamic-producer-consumer/","title":"Dynamic Producer Consumer üìàüìâ"},{"content":"In February of this year we published a paper on undescribed Insect species and genus classification using DNA and image data.\nMy main contributions, together with Roger, were:\nReACGAN for image feature extraction CNN model with vertical kernels for DNA feature extraction Compiling of finetuning dataset for the ReACGAN and CNN, scraping data from BOLDSystemsV3. (Image+DNA) Compiling of pretraining dataset for the ReACGAN, merging previous datasets. (Only Image) Replicating a previous study on the new dataset, since the dataset of the original paper is not publicly available The finetuning dataset can be found at: https://zenodo.org/records/14277812\nThe pretraining dataset can be found at: https://zenodo.org/records/14577906\nThe code can be found at: https://github.com/matteodegobbi/InsectClassification\nPaper: https://www.mdpi.com/1999-4893/18/2/105\\\n","date":"2025-06-18T00:51:54+02:00","image":"https://matteodegobbi.github.io/p/paper-on-insect-species-and-genus-classification/img_hu_d58dc02bc02d1d69.png","permalink":"https://matteodegobbi.github.io/p/paper-on-insect-species-and-genus-classification/","title":"Paper on Insect Species and Genus Classification üêùüêûüêõ"},{"content":"This May I partecipatd at HackUPC 2025, an hackhathon organized by FIB in Barcelona.\nTogether with Vojtƒõch, we built a reinforcement learning agent that learns to play a game similar to Geometry Dash\u0026rsquo;s rocket section. The agent is trained using deep Q-Learning and we built the game using pygame.\nDevpost: https://devpost.com/software/rocket-deep-reinforcement-learning\nCode: https://github.com/matteodegobbi/CaveDescentRL\nVojtƒõch\u0026rsquo;s webiste: https://vojtechbestak.cz/\\\n","date":"2025-06-15T01:27:57+02:00","image":"https://matteodegobbi.github.io/p/cave-descent-reinforcement-learning-game/img_hu_bac54a934ca30e92.png","permalink":"https://matteodegobbi.github.io/p/cave-descent-reinforcement-learning-game/","title":"Cave Descent reinforcement learning game"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 #pragma once #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; template \u0026lt;typename Key, typename Val, int M\u0026gt; class BTree { // M is the minimum degree of the B-tree. // Max keys in a node: 2*M - 1 // Min keys in a non-root node: M - 1 private: struct Node { bool is_leaf; std::vector\u0026lt;Key\u0026gt; keys; std::vector\u0026lt;Val\u0026gt; vals; std::vector\u0026lt;Node *\u0026gt; children; Node(bool leaf = false) : is_leaf(leaf) {} // NOTE: destructor called recursively ~Node() { for (Node *child : children) { delete child; } } }; Node *root = nullptr; int _size = 0; int _height = 0; int split_counter = 0; void _clear(Node *node) { if (node != nullptr) { delete node; // The destructor of sruct Node deletes children recursively } } // NOTE: Functions for search in this section Val *_search(Node *node, const Key \u0026amp;k) { if (node == nullptr) { return nullptr; } // STL binary search to get first element \u0026gt;= to k auto it = std::lower_bound(node-\u0026gt;keys.begin(), node-\u0026gt;keys.end(), k); // get index from iterator int i = std::distance(node-\u0026gt;keys.begin(), it); // found k if (it != node-\u0026gt;keys.end() \u0026amp;\u0026amp; *it == k) { return \u0026amp;node-\u0026gt;vals[i]; } if (node-\u0026gt;is_leaf) { return nullptr; } return _search(node-\u0026gt;children[i], k); } // NOTE: Functions for insertion in this section // // splits the child at `parent-\u0026gt;children[child_index]` void _split_child(Node *parent, int child_index) { split_counter++; Node *child_to_split = parent-\u0026gt;children[child_index]; // create new sibling for splitting the node in half Node *new_child = new Node(child_to_split-\u0026gt;is_leaf); // Promote the median key and value to the parent node parent-\u0026gt;keys.insert(parent-\u0026gt;keys.begin() + child_index, child_to_split-\u0026gt;keys[M - 1]); parent-\u0026gt;vals.insert(parent-\u0026gt;vals.begin() + child_index, child_to_split-\u0026gt;vals[M - 1]); // Put the sibling as a child of the parent // It will be the sibling to the right of the split node parent-\u0026gt;children.insert(parent-\u0026gt;children.begin() + child_index + 1, new_child); // move half of keys and values to the split node\u0026#39;s sibling new_child-\u0026gt;keys.assign(child_to_split-\u0026gt;keys.begin() + M, child_to_split-\u0026gt;keys.end()); new_child-\u0026gt;vals.assign(child_to_split-\u0026gt;vals.begin() + M, child_to_split-\u0026gt;vals.end()); child_to_split-\u0026gt;keys.resize(M - 1); child_to_split-\u0026gt;vals.resize(M - 1); // if the split node was not a leaf, move its children into its new sibling if (!child_to_split-\u0026gt;is_leaf) { new_child-\u0026gt;children.assign(child_to_split-\u0026gt;children.begin() + M, child_to_split-\u0026gt;children.end()); child_to_split-\u0026gt;children.resize(M); } } // NOTE: IMPORTANT INVARIANT node should not be already full // otherwise it will overflow, only call this from public method void _insert_rec(Node *node, const Key \u0026amp;k, const Val \u0026amp;v) { // STL binary search to get index of first key \u0026gt;= k auto it = std::lower_bound(node-\u0026gt;keys.begin(), node-\u0026gt;keys.end(), k); int i = std::distance(node-\u0026gt;keys.begin(), it); // get index in vector of iterator it if (node-\u0026gt;is_leaf) { // case where we found already existing key, update the val if (it != node-\u0026gt;keys.end() \u0026amp;\u0026amp; *it == k) { node-\u0026gt;vals[i] = v; return; } // regular case just insert the key in the leaf node-\u0026gt;keys.insert(it, k); node-\u0026gt;vals.insert(node-\u0026gt;vals.begin() + i, v); _size++; } else { // case where we found already existing key, update the val, same as in // leaf if (it != node-\u0026gt;keys.end() \u0026amp;\u0026amp; *it == k) { node-\u0026gt;vals[i] = v; return; } // NOTE: important, guarantees that no node will overflow // splits the child we will visit recursively in case // it\u0026#39;s already full if (node-\u0026gt;children[i]-\u0026gt;keys.size() == 2 * M - 1) { _split_child(node, i); // increase variabile i in case i need to go to the new sibling after // the split if (k \u0026gt; node-\u0026gt;keys[i]) { i++; } } _insert_rec(node-\u0026gt;children[i], k, v); } } // NOTE: Functions for deletion in this section std::pair\u0026lt;Key, Val\u0026gt; _get_pred(Node *node, int i) { Node *cur = node-\u0026gt;children[i]; while (!cur-\u0026gt;is_leaf) { cur = cur-\u0026gt;children.back(); } return {cur-\u0026gt;keys.back(), cur-\u0026gt;vals.back()}; } std::pair\u0026lt;Key, Val\u0026gt; _get_succ(Node *node, int i) { Node *cur = node-\u0026gt;children[i + 1]; while (!cur-\u0026gt;is_leaf) { cur = cur-\u0026gt;children.front(); } return {cur-\u0026gt;keys.front(), cur-\u0026gt;vals.front()}; } void _borrow_from_prev(Node *node, int i) { Node *child = node-\u0026gt;children[i]; Node *sibling = node-\u0026gt;children[i - 1]; // take key from parent child-\u0026gt;keys.insert(child-\u0026gt;keys.begin(), node-\u0026gt;keys[i - 1]); child-\u0026gt;vals.insert(child-\u0026gt;vals.begin(), node-\u0026gt;vals[i - 1]); // eventually add children inherited from key taken from parent if (!child-\u0026gt;is_leaf) { child-\u0026gt;children.insert(child-\u0026gt;children.begin(), sibling-\u0026gt;children.back()); sibling-\u0026gt;children.pop_back(); } node-\u0026gt;keys[i - 1] = sibling-\u0026gt;keys.back(); node-\u0026gt;vals[i - 1] = sibling-\u0026gt;vals.back(); sibling-\u0026gt;keys.pop_back(); sibling-\u0026gt;vals.pop_back(); } void _borrow_from_next(Node *node, int i) { Node *child = node-\u0026gt;children[i]; Node *sibling = node-\u0026gt;children[i + 1]; child-\u0026gt;keys.push_back(node-\u0026gt;keys[i]); child-\u0026gt;vals.push_back(node-\u0026gt;vals[i]); if (!child-\u0026gt;is_leaf) { child-\u0026gt;children.push_back(sibling-\u0026gt;children.front()); sibling-\u0026gt;children.erase(sibling-\u0026gt;children.begin()); } node-\u0026gt;keys[i] = sibling-\u0026gt;keys.front(); node-\u0026gt;vals[i] = sibling-\u0026gt;vals.front(); sibling-\u0026gt;keys.erase(sibling-\u0026gt;keys.begin()); sibling-\u0026gt;vals.erase(sibling-\u0026gt;vals.begin()); } void _merge(Node *node, int i) { Node *child = node-\u0026gt;children[i]; Node *sibling = node-\u0026gt;children[i + 1]; child-\u0026gt;keys.push_back(node-\u0026gt;keys[i]); child-\u0026gt;vals.push_back(node-\u0026gt;vals[i]); child-\u0026gt;keys.insert(child-\u0026gt;keys.end(), sibling-\u0026gt;keys.begin(), sibling-\u0026gt;keys.end()); child-\u0026gt;vals.insert(child-\u0026gt;vals.end(), sibling-\u0026gt;vals.begin(), sibling-\u0026gt;vals.end()); if (!child-\u0026gt;is_leaf) { child-\u0026gt;children.insert(child-\u0026gt;children.end(), sibling-\u0026gt;children.begin(), sibling-\u0026gt;children.end()); sibling-\u0026gt;children.clear(); // Important: prevent double deletion } node-\u0026gt;keys.erase(node-\u0026gt;keys.begin() + i); node-\u0026gt;vals.erase(node-\u0026gt;vals.begin() + i); node-\u0026gt;children.erase(node-\u0026gt;children.begin() + i + 1); delete sibling; } void _fill(Node *node, int i) { // if i can borrow from left sibling if (i != 0 \u0026amp;\u0026amp; node-\u0026gt;children[i - 1]-\u0026gt;keys.size() \u0026gt;= M) { _borrow_from_prev(node, i); // if i can borrow from right sibling } else if (i != node-\u0026gt;keys.size() \u0026amp;\u0026amp; node-\u0026gt;children[i + 1]-\u0026gt;keys.size() \u0026gt;= M) { _borrow_from_next(node, i); // if i cannot borrow i need to merge the siblings into a node } else { if (i != node-\u0026gt;keys.size()) { _merge(node, i); } else { _merge(node, i - 1); } } } void _remove_in_leaf(Node *node, int i) { node-\u0026gt;keys.erase(node-\u0026gt;keys.begin() + i); node-\u0026gt;vals.erase(node-\u0026gt;vals.begin() + i); _size--; } void _remove_in_internal(Node *node, int i) { Key k = node-\u0026gt;keys[i]; if (node-\u0026gt;children[i]-\u0026gt;keys.size() \u0026gt;= M) { auto [pred_key, pred_val] = _get_pred(node, i); node-\u0026gt;keys[i] = pred_key; node-\u0026gt;vals[i] = pred_val; _remove(node-\u0026gt;children[i], pred_key); } else if (node-\u0026gt;children[i + 1]-\u0026gt;keys.size() \u0026gt;= M) { auto [succ_key, succ_val] = _get_succ(node, i); node-\u0026gt;keys[i] = succ_key; node-\u0026gt;vals[i] = succ_val; _remove(node-\u0026gt;children[i + 1], succ_key); } else { _merge(node, i); _remove(node-\u0026gt;children[i], k); } } void _remove(Node *node, const Key \u0026amp;k) { // STL binary search to get index of first key \u0026gt;= k auto it = std::lower_bound(node-\u0026gt;keys.begin(), node-\u0026gt;keys.end(), k); int i = std::distance(node-\u0026gt;keys.begin(), it); if (i \u0026lt; node-\u0026gt;keys.size() \u0026amp;\u0026amp; node-\u0026gt;keys[i] == k) { if (node-\u0026gt;is_leaf) { _remove_in_leaf(node, i); } else { _remove_in_internal(node, i); } } else { if (node-\u0026gt;is_leaf) { return; // key not found nothing is removed } bool is_last_child = (i == node-\u0026gt;keys.size()); // to keep invariant about minimum number of keys // in a node is \u0026gt;= M-1 if (node-\u0026gt;children[i]-\u0026gt;keys.size() \u0026lt; M) { _fill(node, i); } if (is_last_child \u0026amp;\u0026amp; i \u0026gt; node-\u0026gt;keys.size()) { _remove(node-\u0026gt;children[i - 1], k); } else { _remove(node-\u0026gt;children[i], k); } } } // NOTE: other functions not related to search, insertio and removal in this // section void _inorder(Node *node, std::vector\u0026lt;std::pair\u0026lt;Key, Val\u0026gt;\u0026gt; \u0026amp;v) const { if (node == nullptr) return; int i; for (i = 0; i \u0026lt; node-\u0026gt;keys.size(); i++) { if (!node-\u0026gt;is_leaf) { _inorder(node-\u0026gt;children[i], v); } v.push_back(std::make_pair(node-\u0026gt;keys[i], node-\u0026gt;vals[i])); } if (!node-\u0026gt;is_leaf) { _inorder(node-\u0026gt;children[i], v); } } // NOTE: only used for testing the actual height // computation dont use this, it\u0026#39;s super naive int _height_naive(Node *node) const { if (node == nullptr) { return -1; } if (node-\u0026gt;is_leaf) { return 0; } int max_child_height = -1; for (Node *child : node-\u0026gt;children) { int child_height = _height_naive(child); max_child_height = std::max(max_child_height, child_height); } return 1 + max_child_height; } public: BTree() { root = new Node(true); } ~BTree() { _clear(root); } int size() const { return _size; } bool empty() const { return _size == 0; } void insert(const Key \u0026amp;k, const Val \u0026amp;v) { split_counter = 0; Node *r = root; // if root is full make a new one with old root as child if (r-\u0026gt;keys.size() == 2 * M - 1) { Node *s = new Node(); root = s; s-\u0026gt;children.push_back(r); _split_child(s, 0); ++_height; _insert_rec(s, k, v); } else { _insert_rec(r, k, v); } } void remove(const Key \u0026amp;k) { if (!root) { return; } _remove(root, k); // NOTE: case where we need to shrink tree height by 1 if (root-\u0026gt;keys.empty() \u0026amp;\u0026amp; !root-\u0026gt;is_leaf) { Node *old_root = root; root = root-\u0026gt;children[0]; old_root-\u0026gt;children .clear(); // Prevent destructor from deleting the new root delete old_root; --_height; } } Val \u0026amp;search(const Key \u0026amp;k) { Val *result = _search(root, k); if (result == nullptr) { throw std::runtime_error(\u0026#34;Key not found\u0026#34;); } return *result; } const Val \u0026amp;search(const Key \u0026amp;k) const { Val *result = _search(root, k); if (result == nullptr) { throw std::runtime_error(\u0026#34;Key not found\u0026#34;); } return *result; } bool contains(const Key \u0026amp;k) { return _search(root, k) != nullptr; } void inorder_vector(std::vector\u0026lt;std::pair\u0026lt;Key, Val\u0026gt;\u0026gt; \u0026amp;v) const { v.clear(); _inorder(root, v); } int height() const { return _height; } int last_insert_splits() const { return split_counter; } void clear() { _clear(root); root = new Node(true); _size = 0; } // NOTE: only used for testing the actual height // computation dont use this, it\u0026#39;s super naive int _height_naive() { return _height_naive(root); } }; ","date":"2025-06-13T23:34:39+02:00","permalink":"https://matteodegobbi.github.io/p/prova_codice/","title":"Prova_codice"},{"content":"Pagina di prova! Vediamo se funziona üò≥\n","date":"2022-06-12T23:03:09+02:00","permalink":"https://matteodegobbi.github.io/p/prova2/","title":"prova2"}]